# Descriptives

Here, we get the descriptive info for both studies that we report in the Method section of the paper.
First, let's load the packages we need and load the data sets.
```{r}
library(pacman)

p_load(
  tidyverse,
  sjPlot,
  here,
  patchwork,
  cowplot,
  ggbeeswarm
)
```

Get the data sets.
```{r}
ac <- read_rds(here("data/noa/ac-excluded.rds"))
pvz <- read_rds(here("data/ea/pvz-excluded.rds"))
```

## Create joint dataset

Join the two data sets.

```{r}
ac <- ac %>% 
  select(
    age,
    sex,
    player_id,
    spane_balance, autonomy, 
    competence, relatedness, enjoyment, 
    extrinsic, active_play, Hours
  )

dat <- bind_rows(
  pvz %>% 
  select(
    player_id, age, sex = gender, spane_balance, autonomy, 
    competence, relatedness, enjoyment, 
    extrinsic, active_play, Hours
  ), 
  ac, 
  .id = "Study"
  ) %>% 
  # ! here to remind that data contains simulated stuff in prep for real data
  mutate(Study = factor(Study, labels = c("PVZ", "AC:NH")))
```

## Plot studies combined

Then, let's plot and describe demographic information first.
The plots in this section will be for both studies combined.
```{r}
# raincloud plot function from https://github.com/RainCloudPlots/RainCloudPlots/blob/master/tutorial_R/R_rainclouds.R
# Defining the geom_flat_violin function ----
# Note: the below code modifies the
# existing github page by removing a parenthesis in line 50

"%||%" <- function(a, b) {
  if (!is.null(a)) a else b
}

geom_flat_violin <- function(mapping = NULL, data = NULL, stat = "ydensity",
                             position = "dodge", trim = TRUE, scale = "area",
                             show.legend = NA, inherit.aes = TRUE, ...) {
  layer(
    data = data,
    mapping = mapping,
    stat = stat,
    geom = GeomFlatViolin,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      trim = trim,
      scale = scale,
      ...
    )
  )
}

#' @rdname ggplot2-ggproto
#' @format NULL
#' @usage NULL
#' @export
GeomFlatViolin <-
  ggproto("GeomFlatViolin", Geom,
    setup_data = function(data, params) {
      data$width <- data$width %||%
        params$width %||% (resolution(data$x, FALSE) * 0.9)

      # ymin, ymax, xmin, and xmax define the bounding rectangle for each group
      data %>%
        group_by(group) %>%
        mutate(
          ymin = min(y),
          ymax = max(y),
          xmin = x,
          xmax = x + width / 2
        )
    },

    draw_group = function(data, panel_scales, coord) {
      # Find the points for the line to go all the way around
      data <- transform(data,
        xminv = x,
        xmaxv = x + violinwidth * (xmax - x)
      )

      # Make sure it's sorted properly to draw the outline
      newdata <- rbind(
        plyr::arrange(transform(data, x = xminv), y),
        plyr::arrange(transform(data, x = xmaxv), -y)
      )

      # Close the polygon: set first and last point the same
      # Needed for coord_polar and such
      newdata <- rbind(newdata, newdata[1, ])

      ggplot2:::ggname("geom_flat_violin", GeomPolygon$draw_panel(newdata, panel_scales, coord))
    },

    draw_key = draw_key_polygon,

    default_aes = aes(
      weight = 1, colour = "grey20", fill = "white", size = 0.5,
      alpha = NA, linetype = "solid"
    ),

    required_aes = c("x", "y")
  )

# function that returns summary stats
describe <- function(
  dat,
  variable,
  trait = FALSE
){
  # if variable is not repeated-measures, take only one measure per participant
  if (trait == TRUE){
    dat <- 
      dat %>%
      group_by(player_id) %>% 
      slice(1) %>% 
      ungroup()
  }
  
  # then get descriptives
  descriptives <-
    dat %>%
    filter(!is.na(UQ(sym(variable)))) %>% # remove missing values
    summarise(
      across(
        !! variable,
        list(
          N = ~ n(),
          mean = mean,
          sd = sd,
          median = median,
          min = min,
          max = max,
          cilow = ~Rmisc::CI(.x)[[3]], # lower CI
          cihigh = ~Rmisc::CI(.x)[[1]] # upper CI
        )
      )
    )

  descriptives <-
    descriptives %>%

    # only keep measure
    rename_all(
      ~ str_remove(
        .,
        paste0(variable, "_")
      )
    ) %>%
    mutate(
      variable = variable,
      range = max - min
    ) %>%
    relocate(variable) %>%
    relocate(
      range,
      .after = max
    )
  
  return(descriptives)
}

single_cloud <- 
  function(
    raw_data,
    summary_data,
    variable,
    color,
    title,
    trait = FALSE
  ){
    
    # take only one row per person if it's a trait variable
    if (trait == TRUE){
      raw_data <-
        raw_data %>% 
        group_by(player_id) %>% 
        slice(1) %>% 
        ungroup()
    }
    
    # the plot
    p <- 
      ggplot(
        raw_data %>%
          mutate(Density = 1),
        aes(
          x = Density,
          y = get(variable)
        )
      ) +
      geom_flat_violin( # the "cloud"
        position = position_nudge(x = .2, y = 0),
        adjust = 2,
        color = NA,
        fill = color,
        alpha = 0.5
      ) +
      geom_point( # the "rain"
        position = position_jitter(width = .15),
        size = 1,
        color = color,
        alpha = 0.5
      ) +
      geom_point( # the mean from the summary stats
        data = summary_data %>%
          filter(variable == !! variable) %>%
          mutate(Density = 1),
        aes(
          x = Density + 0.175,
          y = mean
        ),
        color = color,
        size = 2.5
      ) +
      geom_errorbar( # error bars
        data = summary_data %>%
          filter(variable == !! variable) %>%
          mutate(Density = 1),
        aes(
          x = Density + 0.175,
          y = mean,
          ymin = cilow,
          ymax = cihigh
        ),
        width = 0,
        size = 0.8,
        color = color
      ) +
      ylab(title) +
      theme_cowplot() +
      theme(
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_blank(),
        axis.line = element_blank()
      ) +
      guides(
        color = FALSE,
        fill = FALSE
      ) +
      coord_flip()
    
    return(p)
  }

single_cloud(
  dat,
  describe(dat, "age", trait = FALSE),
  "age",
  "#009E73",
  "Distribution of age"
)
```

In total, `r length(unique(dat$player_id))` players responded to the survey.
Their mean age was *M* = `r round(mean(dat$age, na.rm = T), digits = 0)` with a standard deviation of *SD* = `r round(sd(dat$age, na.rm = T), digits = 0)`.

Then let's look at the gender distribution.
```{r}
count(dat, sex) %>% 
  mutate(Proportion = round(n / sum(n), digits = 2) * 100) %>% 
  knitr::kable(., caption = "Gender frequencies")
```

And a check of the variable distributions.
```{r}
p1 <- 
  single_cloud(
    pvz,
    describe(pvz, "spane_balance", trait = TRUE),
    "spane_balance",
    "#56B4E9",
    title = "SPANE Balance",
    trait = TRUE
  )

p2 <- 
  single_cloud(
    pvz,
    describe(pvz, "autonomy", trait = TRUE),
    "autonomy",
    "#009E73",
    title = "Autonomy",
    trait = TRUE
  )

p3 <- 
  single_cloud(
    pvz,
    describe(pvz, "competence", trait = TRUE),
    "competence",
    "#F0E442",
    title = "Competence",
    trait = TRUE
  )

p4 <- 
  single_cloud(
    pvz,
    describe(pvz, "relatedness", trait = TRUE),
    "relatedness",
    "#000000",
    title = "Relatedness",
    trait = TRUE
  )

p5 <- 
  single_cloud(
    pvz,
    describe(pvz, "enjoyment", trait = TRUE),
    "enjoyment",
    "#0072B2",
    title = "Enjoyment",
    trait = TRUE
  )

p6 <- 
  single_cloud(
    pvz,
    describe(pvz, "extrinsic", trait = TRUE),
    "extrinsic",
    "#D55E00",
    title = "Extrinsic motivation",
    trait = TRUE
  )

p7 <- 
  single_cloud(
    pvz,
    describe(pvz, "active_play", trait = TRUE),
    "active_play",
    "#CC79A7",
    title = "Self-estimated play",
    trait = TRUE
  )

(p1 | p2) / (p3 | p4) / (p5 | p6) / p7
```

## Create summary figure

Alright, here I'll create a summary figure that shows a beeswarm plot for each of the variables we're interested in.

First, because we'll plot per measure, let's turn the data into the long format.
```{r}
dat_long <- 
  dat %>% 
  pivot_longer(
    spane_balance:Hours,
    names_to = "Variable",
    values_to = "value"
  ) %>% 
  mutate(Variable = as.factor(Variable))
```

Now, let's get summary stats for each measure.
```{r}
# function to get summary stats
get_summary <- 
  function(
    dat
  ) {
    summary_stats <- 
      dat %>%
      group_by(Study) %>% 
      summarise(
        across(
          spane_balance:Hours,
          list(
            N = ~ sum(!is.na(.x)),
            Mean = ~ mean(.x, na.rm = TRUE),
            SD = ~ sd(.x, na.rm = TRUE),
            Median = ~ median(.x, na.rm = TRUE),
            Min = ~ min(.x, na.rm = TRUE),
            Max = ~ max(.x, na.rm = TRUE),
            `Lower 95%CI` = ~Rmisc::CI(na.omit(.x))[[3]], # lower CI
            `Upper 95%CI` = ~Rmisc::CI(na.omit(.x))[[1]]
          )
        )
      ) %>% 
      
      # get into long format
      pivot_longer(
        -Study,
        names_to = c("Variable", "Measure"),
        values_to = "Value",
        names_pattern = "(.*)_([^_]+$)" # match by last occurrence of underscore
      ) %>%

      # and back to wide format
      pivot_wider(
        id_cols = c(Study, Variable),
        names_from = Measure,
        values_from = Value
      )
    
    return(summary_stats)
    }

summary_stats <- get_summary(dat)

# rename both so that we have the same order of factor levels for the figure
rename_and_relevel <- 
  function(
    dat
  ) {
    dat <- 
      dat %>% 
      mutate(
        Variable = fct_relevel(
          Variable,
          "SPANE" = "spane_balance",
          "Hours",
          "active_play",
          "autonomy",
          "competence",
          "relatedness",
          "enjoyment",
          "extrinsic"
        ),
        
      Variable = fct_recode(
        Variable,
        "SPANE" = "spane_balance",
        "Objective play time" = "Hours",
        "Self-reported play time" = "active_play",
        "Autonomy" = "autonomy",
        "Competence" = "competence",
        "Relatedness" = "relatedness",
        "Enjoyment" = "enjoyment",
        "Extrinsic" = "extrinsic"
      )
    )
    
    return(dat)
  }

dat_long <- rename_and_relevel(dat_long)
summary_stats <- rename_and_relevel(summary_stats)
```

And then the beeswarm plots.
```{r, message=F, warning=F}
summary_stats <-
  summary_stats %>% 
  group_by(Variable) %>% 
  mutate( # the position of geom_text
    x = max(Max) * 0.9,
    across(
      c(Mean, SD),
      ~ round(.x, digits = 1)
    )
  )

# a function because we "split" up the plot with patchwork
beeswarm_plots <- 
  function(
    dat,
    subset,
    mean_position,
    sd_position,
    col_font_size,
    row_font_size
  ){
    ggplot(
      dat %>% 
        filter(
          !Variable %in% subset
        ),
      aes(
        x = value,
        y = 1
      )
    ) +
      geom_quasirandom(
        color = "grey30", 
        size = 0.8, 
        groupOnX = FALSE
      ) +
      facet_grid(
        Study ~ Variable, 
        scales = "free_x"
      ) +
      geom_text(
        data = summary_stats %>% 
          filter(!Variable %in% subset),
        aes(
          x = x,
          y = mean_position,
          label = paste0("M = ", Mean)
        )
      ) +
      geom_text(
        data = summary_stats %>% 
          filter(!Variable %in% subset),
        aes(
          x = x,
          y = sd_position,
          label = paste0("SD = ", SD)
        )
      ) +
      theme(
        axis.text.y = element_blank(),
        axis.title.x = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.y = element_blank(),
        axis.line = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        strip.background.x = element_blank(),
        strip.background.y = element_blank(),
        panel.border = element_rect(
          colour = "black", 
          fill = NA, 
          size = 1
        ),
        strip.text.x = element_text(size = col_font_size),
        strip.text.y = element_text(size = row_font_size)
      ) -> p
    
    return(p)
  }

p1 <- 
  beeswarm_plots(
    dat_long,
    c("Competence", "Relatedness", "Enjoyment", "Extrinsic", "Autonomy"),
    1.6,
    1.5,
    14,
    16
  )

p2 <- 
  beeswarm_plots(
    dat_long,
    c("SPANE", "Objective play time", "Self-reported play time"),
    1.9,
    1.8,
    16,
    16
  )

p1 / p2
```

Last, PVZ also had additional telemetry data besides game playing time.
Below, I create a table with summary stats for those variables.
```{r}
my_names <- 
  c(
    "Total kill count",
    "Total death count",
    "Score",
    "Damage dealt",
    "Critical hits count",
    "Shots fired",
    "Shots hit",
    "Friends made",
    "Objective time played (in h)",
    "Gestures used",
    "Levels gained",
    "Prestige levels gained",
    "XP earned"
  )

# function to get an APA table with descriptive info
get_table <- 
  function(
    dat,
    variable_names,
    file_name
  ) {
    dat %>% 
      summarise(
        across(
          everything(),
          list(
            N = ~ n(),
            Mean = ~ mean(.x, na.rm = TRUE),
            SD = ~ sd(.x, na.rm = TRUE),
            Median = ~ median(.x, na.rm = TRUE),
            Min = ~ min(.x, na.rm = TRUE),
            Max = ~ max(.x, na.rm = TRUE),
            `Lower 95%CI` = ~Rmisc::CI(na.omit(.x))[[3]], # lower CI
            `Upper 95%CI` = ~Rmisc::CI(na.omit(.x))[[1]]
          )
        )
      ) %>% 
      
      # get into long format
      pivot_longer(
        everything(),
        names_to = c("Variable", "Measure"),
        values_to = "Value",
        names_pattern = "(.*)_([^_]+$)" # match by last occurrence of underscore
      ) %>%
      
      # and back to wide format
      pivot_wider(
        id_cols = Variable,
        names_from = Measure,
        values_from = Value
      ) %>% 
      
      # round everything to two digits
      mutate(
        across(
          -Variable,
          ~ round(.x, digits = 2)
        )
      ) %>% 
      
      # give proper names
      mutate(
        Variable = variable_names # function argument
      ) %>%  
      
      # print as apa table
      tab_df( # fro sjPlot package
        ., 
        file = file_name)
  }

get_table(
  pvz %>% 
    select(
      total_kill_count:xp
    ),
  my_names,
  "pvz_telemetry_descriptives.doc"
)
```

